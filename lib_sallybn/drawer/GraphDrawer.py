# ----------------------------------------------------------------------------
#
# Sally BN: An Open-Source Framework for Bayesian Networks.
#
# ----------------------------------------------------------------------------
# GNU General Public License v2
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program; if not, write to the Free Software Foundation, Inc.,
#   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# ----------------------------------------------------------------------------

import math
from gi.repository import Gtk, Gdk

from lib_sallybn.drawer import color
from lib_sallybn.drawer.GStateBox import box_width, title_height, delta_state


class GraphDrawer:
    def __init__(self):
        #### Objects to show #####
        self.objects_to_show = []
        # self.dynamic_arrow = None
        # # circles
        # self.vertices = {}
        # # highlighted circles
        # self.selected_vertices = []
        # # edges
        # self.edges_type_vertex = []
        # self.edges_type_box = []
        # # boxes
        # self.boxes = []
        # self.selected_edges = []

        # Transform for scale
        self.transform = None
        # Translations
        self.translation = [0, 0]
        self.last_translation = [0, 0]
        # Scale and zoom
        self.scale = 1
        self.delta_zoom = 0.1

        ##Viewer mode
        self.viewer_mode = True

        self.area = Gtk.DrawingArea()
        self.area.add_events(Gdk.EventMask.BUTTON_PRESS_MASK | Gdk.EventMask.SCROLL_MASK |
                             Gdk.EventMask.SMOOTH_SCROLL_MASK | Gdk.EventMask.ALL_EVENTS_MASK)

        self.area.connect("motion-notify-event", self.on_motion_event)
        self.area.connect("draw", self.on_drawing_area_draw)
        self.area.connect("scroll-event", self.on_scroll)
        self.area.connect("button-press-event", self.on_button_press)
        self.area.connect("button-release-event", self.on_button_release)

        #Mouse events
        self.button_pressed = False
        self.clicked_point = None
        self.area.set_visible(True)

    def get_drawing_area(self):
        return self.area

    def transform_point(self, p):
        """ Transform a point based on applied scale.
        """
        new_p = self.transform.transform_point(p[0], p[1])
        return new_p

    def on_button_press(self, widget, event):
        """
        Button pressed on drawing area.
        """
        self.button_pressed = True
        p = [event.x, event.y]
        ## Click on edit area to TRANSLATE
        if event.button == 1:
            self.clicked_point = p
            # # For translation in drawing area.
            self.last_translation[0] += self.translation[0]
            self.last_translation[1] += self.translation[1]

            self.translation = [0, 0]
            # print self.last_translation, self.translation

    def on_button_release(self, widget, event):
        """
        Button release on the drawing area.
        """
        # Right click or middle click does not matter
        if event.button > 1:
            return

        p = [event.x, event.y]

        dx, dy = [self.clicked_point[0] - p[0], self.clicked_point[1] - p[1]]
        click_distance = math.hypot(dx, dy)
        # normal click
        if click_distance < 10.0:
            self.translation = [0, 0]

        self.clicked_point = None
        self.button_pressed = False

    def on_motion_event(self, widget, event):
        """
        Event generated by the mouse motion on the drawing area.
        """
        p = self.transform_point([event.x, event.y])

        if self.clicked_point is None:
            return

        #TODO translate node
        #if self.clicked_point is not None and self.mode == Mode.edit and self.selected_vetex is not None:
        #    self.vertex_locations[self.selected_vetex] = p
        #    self.area.queue_draw()

        # translate world  is not None  and
        if self.viewer_mode and self.button_pressed:
            p = [event.x, event.y]

            dx, dy = [self.clicked_point[0] - p[0], self.clicked_point[1] - p[1]]
            self.translation[0] = -dx / self.scale
            self.translation[1] = -dy / self.scale

            self.area.queue_draw()

    def on_scroll(self, widget, event):
        """
        Scroll event by the mouse. It modifies the scale for drawing.
        """
        self.scale -= self.delta_zoom * event.delta_y
        self.area.queue_draw()

    def on_drawing_area_draw(self, drawing_area, cairo):
        """
        Draw on the drawing area!
        """
        # Sacale
        cairo.scale(self.scale, self.scale)
        # Translate
        tx = self.translation[0] + self.last_translation[0]
        ty = self.translation[1] + self.last_translation[1]
        cairo.translate(tx, ty)

        # print (tx, ty), self.last_translation

        # Get transformation
        self.transform = cairo.get_matrix()
        self.transform.invert()

        #### Drawing ####
        # Background
        cairo.set_source_rgb(*color.white)
        cairo.rectangle(-10000, -10000, 100000, 1000000)
        cairo.fill()

        #TODO dynamic arrow

        # show objects
        for o in self.objects_to_show:
            o.draw(cairo)

    def restore_zoom(self):
        self.translation = [0, 0]
        self.last_translation = [0, 0]
        self.scale = 1
        self.area.queue_draw()

    #TODO go away
    def point_in_state(self, p, vertex_locations, marginals):
        """
        :p point to evaluate [x,y]
        :param vertex_locations dic with name and point, ex. {"v1":[x,y]}
        :param marginals dic with marginal probabilities to all variables
            ex. {"v1":{"state1": 0.5, "state2": 0.5}}
        :return: ("vertex", "state")
        """
        x, y = p

        for v, v_position in vertex_locations.iteritems():
            # states of vertex
            v_states = marginals[v].keys()
            box_heigh = self._get_box_height(v_states)

            # go to left-upper corner
            x_corner = v_position[0] - box_width / 2.0
            y_corner = v_position[1] - box_heigh / 2.0

            #if point.x is not in range
            if not x_corner < x <= x_corner + box_width:
                continue

            # evaluate each state for p.y
            for i in range(len(v_states)):
                ny = y_corner + title_height + i * delta_state
                ny_next = y_corner + title_height + (i + 1) * delta_state

                if ny < y <= ny_next:
                    return v, v_states[i]
        return None


    @staticmethod
    def _get_box_height(num_states):
        return title_height + delta_state * len(num_states)

    ######## SET GRAPHICAL OBJECTS
    def set_graphic_objects(self, graphic_objects):
        """ set a dynamic arrow to show based on mouse motion.
        """
        self.objects_to_show = graphic_objects
        self.area.queue_draw()

    def set_viewer_mode(self, active):
        self.viewer_mode = active

    def repaint(self):
        self.area.queue_draw()